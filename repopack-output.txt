This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-12-13T00:42:47.332Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
MAD9137_Final Assignment_Weather Application/
  Assets.xcassets/
    AccentColor.colorset/
      Contents.json
    AppIcon.appiconset/
      Contents.json
    hiddenPic.imageset/
      Contents.json
    profilePic.imageset/
      Contents.json
    Contents.json
  Models/
    WeatherModel.swift
    WeatherViewModel.swift
  Preview Content/
    Preview Assets.xcassets/
      Contents.json
  Services/
    WeatherService.swift
  Views/
    AboutView.swift
    CityListView.swift
    CityRowView.swift
    CityWeatherDetailView.swift
    ContentView.swift
    MainTabView.swift
    SearchCityView.swift
    SettingsView.swift
  MAD9137_Final_Assignment_Weather_ApplicationApp.swift
MAD9137_Final Assignment_Weather Application.xcodeproj/
  project.xcworkspace/
    contents.xcworkspacedata
  xcuserdata/
    terrywong.xcuserdatad/
      xcdebugger/
        Breakpoints_v2.xcbkptlist
      xcschemes/
        xcschememanagement.plist
  project.pbxproj
File.txt
MAD9137-Final-Assignment-Weather-Application-Info.plist

================================================================
Repository Files
================================================================

================
File: MAD9137_Final Assignment_Weather Application/Assets.xcassets/AccentColor.colorset/Contents.json
================
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: MAD9137_Final Assignment_Weather Application/Assets.xcassets/AppIcon.appiconset/Contents.json
================
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: MAD9137_Final Assignment_Weather Application/Assets.xcassets/hiddenPic.imageset/Contents.json
================
{
  "images" : [
    {
      "filename" : "chiikawa.jpeg",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "chiikawa 1.jpeg",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "chiikawa 2.jpeg",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: MAD9137_Final Assignment_Weather Application/Assets.xcassets/profilePic.imageset/Contents.json
================
{
  "images" : [
    {
      "filename" : "gihub search profile pic.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "gihub search profile pic 1.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "gihub search profile pic 2.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: MAD9137_Final Assignment_Weather Application/Assets.xcassets/Contents.json
================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: MAD9137_Final Assignment_Weather Application/Models/WeatherModel.swift
================
//
//  WeatherModel.swift
//  MAD9137_Final Assignment_Weather Application
//
//  Created by Terry Wong on 11/12/2024.
//

import Foundation

struct WeatherResponse: Codable {
    let main: MainWeather
    let weather: [Weather]
    let name: String
    let dt: Int
    let sys: Sys
    let timezone: Int?
    let coord: Coordinates
    let wind: Wind
}

struct Wind: Codable {
    let speed: Double
}

struct Sys: Codable {
    let country: String
}

struct MainWeather: Codable {
    let temp: Double
    let humidity: Int
}

struct Weather: Codable {
    let description: String
    let icon: String
}

struct Coordinates: Codable {
    let lat: Double
    let lon: Double
}

struct WeatherDetail: Codable {
    let temperature: Double
    let feelsLike: Double
    let humidity: Int
    let pressure: Int
    let windSpeed: Double
    let description: String
    let icon: String
    let hourlyForecast: [HourlyWeatherData]

    init(temperature: Double, feelsLike: Double, humidity: Int, pressure: Int,
         windSpeed: Double, description: String, icon: String,
         hourlyForecast: [HourlyWeatherData])
    {
        self.temperature = temperature
        self.feelsLike = feelsLike
        self.humidity = humidity
        self.pressure = pressure
        self.windSpeed = windSpeed
        self.description = description
        self.icon = icon
        self.hourlyForecast = hourlyForecast
    }
    
    enum CodingKeys: String, CodingKey {
        case main
        case weather
        case wind
        case hourly
    }
    
    enum MainKeys: String, CodingKey {
        case temperature = "temp"
        case feelsLike = "feels_like"
        case humidity
        case pressure
    }
    
    enum WindKeys: String, CodingKey {
        case windSpeed = "speed"
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        let mainContainer = try container.nestedContainer(keyedBy: MainKeys.self, forKey: .main)
        temperature = try mainContainer.decode(Double.self, forKey: .temperature)
        feelsLike = try mainContainer.decode(Double.self, forKey: .feelsLike)
        humidity = try mainContainer.decode(Int.self, forKey: .humidity)
        pressure = try mainContainer.decode(Int.self, forKey: .pressure)
        
        let windContainer = try container.nestedContainer(keyedBy: WindKeys.self, forKey: .wind)
        windSpeed = try windContainer.decode(Double.self, forKey: .windSpeed)
        
        let weatherArray = try container.decode([Weather].self, forKey: .weather)
        guard let firstWeather = weatherArray.first else {
            throw DecodingError.dataCorrupted(DecodingError.Context(
                codingPath: container.codingPath,
                debugDescription: "Weather array is empty"
            ))
        }
        description = firstWeather.description
        icon = firstWeather.icon
        
        // Decode hourly forecast if available
        if let hourlyData = try? container.decode([HourlyForecastResponse].self, forKey: .hourly) {
            hourlyForecast = hourlyData.prefix(24).map { HourlyWeatherData(from: $0) }
        } else {
            hourlyForecast = []
        }
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        var mainContainer = container.nestedContainer(keyedBy: MainKeys.self, forKey: .main)
        try mainContainer.encode(temperature, forKey: .temperature)
        try mainContainer.encode(feelsLike, forKey: .feelsLike)
        try mainContainer.encode(humidity, forKey: .humidity)
        try mainContainer.encode(pressure, forKey: .pressure)
        
        var windContainer = container.nestedContainer(keyedBy: WindKeys.self, forKey: .wind)
        try windContainer.encode(windSpeed, forKey: .windSpeed)
        
        try container.encode([Weather(description: description, icon: icon)], forKey: .weather)
        
        // Encode hourly forecast
        let hourlyResponses = hourlyForecast.map { hourly in
            HourlyForecastResponse(
                dt: Int(hourly.time.timeIntervalSince1970),
                temp: hourly.temperature,
                pop: hourly.precipitation,
                weather: [Weather(description: "", icon: hourly.icon)]
            )
        }
        try container.encode(hourlyResponses, forKey: .hourly)
    }
}

struct DetailedWeatherResponse: Codable {
    struct Current: Codable {
        let temp: Double
        let feels_like: Double
        let humidity: Int
        let pressure: Int
        let wind_speed: Double
        let weather: [Weather]
    }
    
    struct Hourly: Codable {
        let dt: Int
        let temp: Double
        let pop: Double?
        let weather: [Weather]
    }
    
    let current: Current
    let hourly: [Hourly]
}

struct HourlyForecastResponse: Codable {
    let dt: Int
    let temp: Double
    let pop: Double
    let weather: [Weather]
}

struct HourlyWeatherData: Identifiable, Codable {
    let id = UUID()
    let time: Date
    let temperature: Double
    let icon: String
    let precipitation: Double
    
    init(time: Date, temperature: Double, icon: String, precipitation: Double) {
        self.time = time
        self.temperature = temperature
        self.icon = icon
        self.precipitation = precipitation
    }
    
    init(from response: HourlyForecastResponse) {
        time = Date(timeIntervalSince1970: TimeInterval(response.dt))
        temperature = response.temp
        icon = response.weather.first?.icon ?? ""
        precipitation = response.pop
    }
    
//    func encode(to encoder: Encoder) throws {
//        var container = encoder.singleValueContainer()
//        let response = HourlyForecastResponse(
//            dt: Int(time.timeIntervalSince1970),
//            temp: temperature,
//            pop: precipitation,
//            weather: [Weather(description: "", icon: icon)]
//        )
//        try container.encode(response)
//    }
}

struct City: Identifiable, Codable, Hashable {
    var id = UUID()
    let name: String
    let temperature: Double
    let weatherDescription: String
    let weatherIcon: String
    let localTime: Date
    let country: String
    let timeZone: String?
    let coordinates: Coordinates
    let humidity: Int
    let windSpeed: Double
    
    init(name: String, temperature: Double, weatherDescription: String, weatherIcon: String, localTime: Date, country: String, timeZone: String?, coordinates: Coordinates, humidity: Int, windSpeed: Double) {
        self.name = name
        self.temperature = temperature
        self.weatherDescription = weatherDescription
        self.weatherIcon = weatherIcon
        self.localTime = localTime
        self.country = country
        self.timeZone = timeZone
        self.coordinates = coordinates
        self.humidity = humidity
        self.windSpeed = windSpeed
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    static func == (lhs: City, rhs: City) -> Bool {
        lhs.id == rhs.id
    }
}

================
File: MAD9137_Final Assignment_Weather Application/Models/WeatherViewModel.swift
================
//
//  WeatherViewModel.swift
//  MAD9137_Final Assignment_Weather Application
//
//  Created by Terry Wong on 11/12/2024.
//

import Foundation

@MainActor
class WeatherViewModel: ObservableObject {
    @Published var cities: [City] = []
    @Published var isLoading = false
    @Published var error: Error?
    @Published var hourlyForecast: [HourlyWeatherData] = []
    @Published var isTabBarVisible = true
    
    private let weatherService = WeatherService()
    private let userDefaultsKey = "savedCities"
    private var refreshTimer: Timer?
    
    init() {
        loadCities()
        // Start the refresh timer with default interval
        let defaultInterval = UserDefaults.standard.double(forKey: "refreshInterval")
        updateRefreshTimer(interval: defaultInterval > 0 ? defaultInterval : 60.0)
    }
    
    private func loadCities() {
        if let savedCities = UserDefaults.standard.data(forKey: userDefaultsKey) {
            if let decodedCities = try? JSONDecoder().decode([City].self, from: savedCities) {
                cities = decodedCities
                return
            }
        }
        
        // Set default cities if no saved data
        cities = [
            City(name: "Ottawa", temperature: 0, weatherDescription: "", weatherIcon: "", localTime: Date(), country: String(), timeZone: String(), coordinates: Coordinates(lat: 0, lon: 0), humidity: 0, windSpeed: 0),
            City(name: "Tokyo", temperature: 0, weatherDescription: "", weatherIcon: "", localTime: Date(), country: String(), timeZone: String(), coordinates: Coordinates(lat: 0, lon: 0), humidity: 0, windSpeed: 0),
            City(name: "New York", temperature: 0, weatherDescription: "", weatherIcon: "", localTime: Date(), country: String(), timeZone: String(), coordinates: Coordinates(lat: 0, lon: 0), humidity: 0, windSpeed: 0),
            City(name: "London", temperature: 0, weatherDescription: "", weatherIcon: "", localTime: Date(), country: String(), timeZone: String(), coordinates: Coordinates(lat: 0, lon: 0), humidity: 0, windSpeed: 0),
            City(name: "Sydney", temperature: 0, weatherDescription: "", weatherIcon: "", localTime: Date(), country: String(), timeZone: String(), coordinates: Coordinates(lat: 0, lon: 0), humidity: 0, windSpeed: 0)
        ]
        saveCities()
    }
    
    private func saveCities() {
        if let encoded = try? JSONEncoder().encode(cities) {
            UserDefaults.standard.set(encoded, forKey: userDefaultsKey)
        }
    }
    
    func deleteCity(_ city: City) {
        if let index = cities.firstIndex(where: { $0.id == city.id }) {
            cities.remove(at: index)
            saveCities()
        }
    }
    
    func addCity(_ city: City) {
        cities.insert(city, at: 0)
        saveCities()
        // Fetch weather for the newly added city
        fetchAllCityWeather()
    }
    
    func fetchAllCityWeather() {
        Task {
            isLoading = true
            
            var updatedCities: [City] = []
            for cityName in cities.map({ $0.name }) {
                do {
                    let weatherResponse = try await weatherService.fetchWeather(for: cityName)
                    let city = City(
                        name: weatherResponse.name,
                        temperature: weatherResponse.main.temp,
                        weatherDescription: weatherResponse.weather.first?.description ?? "",
                        weatherIcon: weatherResponse.weather.first?.icon ?? "",
                        localTime: Date(timeIntervalSince1970: Double(weatherResponse.dt)),
                        country: weatherResponse.sys.country,
                        timeZone: weatherResponse.timezone.map { String($0) },
                        coordinates: Coordinates(lat: weatherResponse.coord.lat, lon: weatherResponse.coord.lon),
                        humidity: weatherResponse.main.humidity,
                        windSpeed: weatherResponse.wind.speed
                    )
                    updatedCities.append(city)
                } catch {
                    self.error = error
                    print("Error fetching weather for \(cityName): \(error)")
                }
            }
            
            if !updatedCities.isEmpty {
                self.cities = updatedCities
                saveCities()
            }
            
            isLoading = false
        }
    }

    func fetchForecast(for city: City) async {
        isLoading = true
        do {
            let forecast = try await weatherService.fetchForecast(
                lat: city.coordinates.lat,
                lon: city.coordinates.lon
            )
            await MainActor.run {
                self.hourlyForecast = forecast
                self.isLoading = false
            }
        } catch {
            await MainActor.run {
                self.error = error
                self.isLoading = false
            }
            print("Error fetching forecast: \(error)")
        }
    }
    
    func updateRefreshTimer(interval: TimeInterval) {
        // Invalidate existing timer
        refreshTimer?.invalidate()
        
        // Create new timer
        refreshTimer = Timer.scheduledTimer(withTimeInterval: interval, repeats: true) { [weak self] _ in
            Task { @MainActor in
                self?.fetchAllCityWeather()
            }
        }
        
        // Immediately fetch weather
        fetchAllCityWeather()
        
        // Store the interval in UserDefaults
        UserDefaults.standard.set(interval, forKey: "refreshInterval")
    }
        
    deinit {
        refreshTimer?.invalidate()
    }
}

================
File: MAD9137_Final Assignment_Weather Application/Preview Content/Preview Assets.xcassets/Contents.json
================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: MAD9137_Final Assignment_Weather Application/Services/WeatherService.swift
================
//
//  WeatherService.swift
//  MAD9137_Final Assignment_Weather Application
//
//  Created by Terry Wong on 11/12/2024.
//

import Foundation

class WeatherService: ObservableObject {
    private let apiKey = "aadcba574a28095c11c6b00b1dc3e7fc"
    private let baseURL = "https://api.openweathermap.org/data/2.5/weather"

    @Published var cities: [City] = []
    
    func fetchWeather(for cityName: String) async throws -> WeatherResponse {
        let urlString = "\(baseURL)?q=\(cityName)&appid=\(apiKey)&units=metric"
        guard let url = URL(string: urlString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "") else {
            throw WeatherError.invalidURL
        }
                
        let (data, response) = try await URLSession.shared.data(from: url)
                
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200
        else {
            throw WeatherError.invalidResponse
        }
                
        let decoder = JSONDecoder()
        let weatherResponse = try decoder.decode(WeatherResponse.self, from: data)
        return weatherResponse
    }
    
    func fetchDetailedWeather(for city: City) async throws -> (WeatherDetail, [HourlyWeatherData]) {
        let urlString = "https://api.openweathermap.org/data/2.5/forecast?lat=\(city.coordinates.lat)&lon=\(city.coordinates.lon)&units=metric&appid=\(apiKey)"
               
        guard let url = URL(string: urlString) else {
            throw WeatherError.invalidURL
        }
               
        let (data, response) = try await URLSession.shared.data(from: url)
               
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200
        else {
            throw WeatherError.invalidResponse
        }
               
        let decoder = JSONDecoder()
        let detailResponse = try decoder.decode(DetailedWeatherResponse.self, from: data)
               
        // Get hourly forecasts
        let hourlyForecasts = detailResponse.hourly.prefix(5).map { hourly in
            HourlyWeatherData(from: HourlyForecastResponse(
                dt: hourly.dt,
                temp: hourly.temp,
                pop: hourly.pop ?? 0,
                weather: hourly.weather
            ))
        }
               
        let weatherDetail = WeatherDetail(
            temperature: detailResponse.current.temp,
            feelsLike: detailResponse.current.feels_like,
            humidity: detailResponse.current.humidity,
            pressure: detailResponse.current.pressure,
            windSpeed: detailResponse.current.wind_speed,
            description: detailResponse.current.weather.first?.description ?? "",
            icon: detailResponse.current.weather.first?.icon ?? "",
            hourlyForecast: hourlyForecasts
        )
            
        return (weatherDetail, Array(hourlyForecasts))
    }
    
    func fetchForecast(lat: Double, lon: Double) async throws -> [HourlyWeatherData] {
        let urlString = "https://api.openweathermap.org/data/2.5/forecast?lat=\(lat)&lon=\(lon)&units=metric&appid=\(apiKey)"
        
        guard let url = URL(string: urlString) else {
            throw WeatherError.invalidURL
        }
        
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200
        else {
            throw WeatherError.invalidResponse
        }
        
        struct ForecastResponse: Codable {
            struct ForecastItem: Codable {
                let dt: Int
                let main: MainWeather
                let weather: [Weather]
                let pop: Double
            }
            
            let list: [ForecastItem]
        }
        
        let decoder = JSONDecoder()
        let forecastResponse = try decoder.decode(ForecastResponse.self, from: data)
        
        return forecastResponse.list.prefix(8).map { item in // Changed to 8 for 24-hour forecast (3-hour intervals)
            HourlyWeatherData(
                time: Date(timeIntervalSince1970: TimeInterval(item.dt)),
                temperature: item.main.temp,
                icon: item.weather.first?.icon ?? "",
                precipitation: item.pop * 100
            )
        }
    }

    private func formatHour(from date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm"
        return formatter.string(from: date)
    }
}
        
private func formatHour(from date: Date) -> String {
    let formatter = DateFormatter()
    formatter.dateFormat = "HH:mm"
    return formatter.string(from: date)
}

enum WeatherError: Error {
    case invalidURL
    case invalidResponse
    case invalidData
}

struct CurrentWeather: Codable {
    let temp: Double
    let feels_like: Double
    let pressure: Int
    let humidity: Int
    let uvi: Double?
    let visibility: Int
    let wind_speed: Double
    let weather: [Weather]
}

struct HourlyWeather: Codable, Identifiable {
    let dt: Int
    let temp: Double
    let weather: [Weather]
    let pop: Double?
    var id: Int { dt }
}

================
File: MAD9137_Final Assignment_Weather Application/Views/AboutView.swift
================
//
//  AboutView.swift
//  MAD9137_Final Assignment_Weather Application
//
//  Created by Terry Wong on 12/12/2024.
//

import SwiftUI

struct AboutView: View {
    @State private var tapCount = 0
    @State private var showKidPhoto = false

    var body: some View {
        ZStack {
            // Background
            Color(red: 0.4, green: 0.5, blue: 0.9)
                .ignoresSafeArea()
            
            ScrollView {
                VStack(spacing: 30) {
                    // Profile Photo with tap gesture
                    Image(showKidPhoto ? "hiddenPic" : "profilePic")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 300, height: 300)
                        .clipShape(Circle())
                        .onTapGesture {
                            tapCount += 1
                            if tapCount >= 3 {
                                withAnimation(.spring()) {
                                    showKidPhoto.toggle()
                                }
                                tapCount = 0
                            }
                        }
                  
                        .padding(.top, 30)
                    
                    // Profile Info
                    VStack(spacing: 15) {
                        Text("Terry Wong")
                            .font(.title)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                        
                        Text("Student ID: 041101011")
                            .font(.title2)
                            .foregroundColor(.white)
                    }
                    
                    // App Info
                    VStack(spacing: 10) {
                        Text("Version 1.0")
                            .font(.title2)
                            .foregroundColor(.white)
                    }
                    
                    Text("© 2024 Terry Wong")
                        .font(.title2)
                        .foregroundColor(.white)
                        .padding(.top, 30)
                }
                .padding()
            }
        }
        .navigationTitle("About")
    }
}

struct AboutView_Previews: PreviewProvider {
    static var previews: some View {
        AboutView()
            .environmentObject(WeatherViewModel())
    }
}

================
File: MAD9137_Final Assignment_Weather Application/Views/CityListView.swift
================
//
//  CityListView.swift
//  MAD9137_Final Assignment_Weather Application
//
//  Created by Terry Wong on 11/12/2024.
//

import SwiftUI

struct CityListView: View {
    @EnvironmentObject var viewModel: WeatherViewModel
    @State private var showSearchView = false
    @State private var selectedCity: City?

    var body: some View {
        NavigationStack {
            ZStack {
                BackgroundView()
                MainContentView(
                    viewModel: self.viewModel,
                    selectedCity: self.$selectedCity
                )
            }
            .navigationBarSetup(
                showSearchView: self.$showSearchView,
                viewModel: self.viewModel
            ).navigationDestination(for: City.self) { city in
                CityWeatherDetailView(city: city, viewModel: self.viewModel)
            }
        }
        .onAppear {
            self.viewModel.fetchAllCityWeather()
        }
    }
}

private struct BackgroundView: View {
    var body: some View {
        Color(red: 0.4, green: 0.5, blue: 0.9)
            .ignoresSafeArea(.all)
    }
}

private struct MainContentView: View {
    @ObservedObject var viewModel: WeatherViewModel
    @Binding var selectedCity: City?

    var body: some View {
        ScrollView {
            VStack(spacing: 0) {
                LoadingView(isLoading: self.viewModel.isLoading)
                CitiesList(
                    viewModel: self.viewModel,
                    selectedCity: self.$selectedCity
                )
            }
            .background(Color.clear)
        }
        .scrollIndicators(.hidden)
    }
}

private struct LoadingView: View {
    let isLoading: Bool

    var body: some View {
        if self.isLoading {
            ProgressView()
                .tint(.white)
                .scaleEffect(1.5)
                .padding()
        }
    }
}

private struct CitiesList: View {
    @ObservedObject var viewModel: WeatherViewModel
    @Binding var selectedCity: City?

    var body: some View {
        ForEach(self.viewModel.cities) { city in
            NavigationLink(value: city) {
                VStack(spacing: 0) {
                    CityRowView(
                        city: city,
                        onDelete: { self.viewModel.deleteCity(city) },
                        onTap: {}
                    )
                    DividerView()
                }
                .buttonStyle(PlainButtonStyle())
                .tint(.white)
            }
        }
    }
}

private struct DividerView: View {
    var body: some View {
        Rectangle()
            .fill(Color.white.opacity(0.5))
            .frame(width: 370, height: 2)
            .padding(.horizontal, 20)
    }
}

private struct AddButton: View {
    var action: () -> Void

    var body: some View {
        Button(action: self.action) {
            ZStack {
                Circle()
                    .foregroundColor(.white)
                    .frame(width: 25, height: 25)
                Image(systemName: "plus")
                    .foregroundColor(Color(red: 0.4, green: 0.5, blue: 0.9))
                    .font(.subheadline)
            }
        }
    }
}

private extension View {
    func navigationBarSetup(showSearchView: Binding<Bool>, viewModel: WeatherViewModel) -> some View {
        self
            .navigationTitle("Algonquin Weather")
            .navigationBarTitleDisplayMode(.inline)
            .toolbarBackground(Color(red: 0.4, green: 0.5, blue: 0.9), for: .navigationBar)
            .toolbarBackground(.visible)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    AddButton {
                        showSearchView.wrappedValue = true
                    }
                }
            }
            .sheet(isPresented: showSearchView) {
                SearchCityView()
                    .environmentObject(viewModel)
            }
            .toolbarColorScheme(.dark, for: .navigationBar)
    }
}

struct CityListView_Previews: PreviewProvider {
    static var previews: some View {
        MainTabView()
            .environmentObject(WeatherViewModel())
    }
}

================
File: MAD9137_Final Assignment_Weather Application/Views/CityRowView.swift
================
//
//  CityRowView.swift
//  MAD9137_Final Assignment_Weather Application
//
//  Created by Terry Wong on 11/12/2024.
//

import SwiftUI

struct CityRowView: View {
    let city: City
    var onDelete: () -> Void
    var onTap: () -> Void
    @State private var showingDeleteAlert = false
    @State private var currentTime: Date = .init()
    @State private var timer: Timer?
    
    private let timeFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "hh:mm a"
        return formatter
    }()
    
    private func getCurrentLocalTime(for city: City) -> Date {
        guard let timezoneOffset = city.timeZone.flatMap({ Int($0) }) else {
            return Date()
        }
           
        // Get current UTC time
        let currentUTC = Date()
           
        // Add the timezone offset to get local time
        return currentUTC.addingTimeInterval(TimeInterval(timezoneOffset))
    }
       
    private func formatTime(_ date: Date) -> String {
        // Set formatter to UTC to avoid double timezone conversion
        timeFormatter.timeZone = TimeZone(identifier: "UTC")
        return timeFormatter.string(from: date)
    }
       
    private func startTimer() {
        // Update immediately
        updateTime()
           
        // Calculate delay until next minute
        let calendar = Calendar.current
        let seconds = calendar.component(.second, from: Date())
        let delay = 60 - Double(seconds)
           
        // Schedule first update at the start of next minute
        DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
            updateTime()
            // Then update every minute
            timer = Timer.scheduledTimer(withTimeInterval: 60, repeats: true) { _ in
                updateTime()
            }
        }
    }

    private func updateTime() {
        currentTime = getCurrentLocalTime(for: city)
    }
       
    var body: some View {
        HStack(alignment: .top) {
            VStack(alignment: .leading, spacing: 4) {
                HStack(alignment: .top, spacing: 0) {
                    Text("\(Int(round(city.temperature)))")
                        .font(.system(size: 72, weight: .light))
                    Text("°C")
                        .font(.system(size: 24, weight: .light))
                        .padding(.top, 12)
                }
                .foregroundColor(.white)
                
                Text(city.name)
                    .font(.system(size: 32, weight: .regular))
                    .foregroundColor(.white)
                
                Text(formatTime(currentTime))
                    .font(.system(size: 16, weight: .regular))
                    .foregroundColor(.white.opacity(0.8))
            }
            
            Spacer()
            
            VStack(alignment: .trailing, spacing: 2) {
                Button(action: {
                    showingDeleteAlert = true
                }) {
                    Image(systemName: "trash")
                        .foregroundColor(.white.opacity(0.8))
                        .font(.system(size: 20, weight: .bold))
                }
                .padding(.bottom, 12)
                .zIndex(1)
                .buttonStyle(PlainButtonStyle())
                .alert(isPresented: $showingDeleteAlert) {
                    Alert(
                        title: Text("Delete City"),
                        message: Text("Are you sure you want to delete \(city.name)?"),
                        primaryButton: .destructive(Text("Delete")) {
                            onDelete()
                        },
                        secondaryButton: .cancel()
                    )
                }
                
                AsyncImage(url: URL(string: "https://openweathermap.org/img/wn/\(city.weatherIcon)@2x.png")) { image in
                    image
                        .resizable()
                        .scaledToFit()
                        .frame(width: 80, height: 80)
                } placeholder: {
                    ProgressView()
                        .tint(.white)
                }
                
                Text(city.weatherDescription.capitalized)
                    .font(.system(size: 20, weight: .bold))
                    .foregroundColor(.white)
                    .multilineTextAlignment(.center)
                    .lineLimit(2)
            }
        }
        .padding(.horizontal, 20)
        .padding(.vertical, 16)
        .contentShape(Rectangle())
        .background(Color.clear)
        .onAppear {
            startTimer()
        }
        .onDisappear {
            timer?.invalidate()
            timer = nil
        }
    }
}

================
File: MAD9137_Final Assignment_Weather Application/Views/CityWeatherDetailView.swift
================
import MapKit
import SwiftUI

struct CityWeatherDetailView: View {
    let city: City
    @ObservedObject var viewModel: WeatherViewModel
    @Environment(\.dismiss) private var dismiss
    @State private var isCelsius = true
    
    var body: some View {
        ZStack {
            color(for: city.temperature)
                .ignoresSafeArea()
                        
            MapView(coordinate: CLLocationCoordinate2D(
                latitude: city.coordinates.lat,
                longitude: city.coordinates.lon
            ))
            .ignoresSafeArea()
           
            LinearGradient(
                gradient: Gradient(colors: [
                    color(for: city.temperature).opacity(1.2),
                    color(for: city.temperature).opacity(0.7),
                    color(for: city.temperature).opacity(0.6),
                    color(for: city.temperature).opacity(0.4),
                    color(for: city.temperature).opacity(0.2),
                    color(for: city.temperature).opacity(0.1),
         
                ]),
                startPoint: .bottom,
                endPoint: .top
            )
            .ignoresSafeArea()
            
            ScrollView(showsIndicators: false) {
                VStack(spacing: 20) {
                    navigationBar
                    weatherInfo
                    weatherDetails
                    hourlyForecast
                }
                .padding(.horizontal)
            }
        }.toolbar(.hidden, for: .tabBar)
            .navigationBarHidden(true)
            .task {
                print("Starting forecast fetch for \(city.name)")
                await viewModel.fetchForecast(for: city)
                print("Forecast data count: \(viewModel.hourlyForecast.count)")
            }
    }

    private func convertTemperature(_ celsius: Double) -> Double {
        return isCelsius ? celsius : (celsius * 9 / 5) + 32
    }
    
    private func color(for temperature: Double) -> Color {
        let normalized = (temperature + 30) / 70
        return Color(
            hue: (1.0 - normalized) * 2 / 3,
            saturation: 1.0,
            brightness: 0.7
        )
    }
    
    private var navigationBar: some View {
        HStack {
            Button(action: { dismiss() }) {
                Image(systemName: "chevron.left")
                    .foregroundColor(.black)
                    .padding(18)
                    .background(Color.white.opacity(0.9))
                    .clipShape(Circle())
            }
            
            Spacer()
        }
    }
    
    private var weatherInfo: some View {
        VStack(spacing: 24) {
            Text(city.name)
                .font(.system(size: 50, weight: .semibold))
                .fontWeight(.bold)
                .foregroundColor(.white)
            
            // Modified temperature display with toggle
            VStack {
                Text("\(Int(round(convertTemperature(city.temperature))))°\(isCelsius ? "C" : "F")")
                    .font(.system(size: 120, weight: .semibold))
                    .foregroundColor(.white)
                    .onTapGesture {
                        isCelsius.toggle()
                    }
            }
            
            Text("\(formatDate(city.localTime))")
                .font(.system(size: 30, weight: .semibold))
                .foregroundColor(.white)
        }
        .padding(.bottom, 40)
    }
  
    private var weatherDetails: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 20)
                .fill(.ultraThinMaterial)
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            HStack(spacing: 13) {
                WeatherDetailCard(icon: "wind", title: "Wind", value: "\(Int(city.windSpeed)) m/s")
                WeatherDetailCard(icon: "humidity", title: "Humidity", value: "\(city.humidity)%")
            }
        }
    }
    
    private var hourlyForecast: some View {
        VStack(alignment: .leading, spacing: 15) {
            Text("5-Day Forecast")
                .font(.title3)
                .fontWeight(.semibold)
                .foregroundColor(.white)
                   
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 20) {
                    ForEach(viewModel.hourlyForecast) { forecast in
                        HourlyForecastCard(
                            hour: formatForecastTime(forecast.time),
                            temperature: Int(forecast.temperature),
                            icon: forecast.icon
                        )
                    }
                }
                .padding(.horizontal)
            }
        }
        .padding()
    }

    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "E, d MMM"
        return formatter.string(from: date)
    }

    private func formatHour(from date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:00"
        return formatter.string(from: date)
    }
}

struct MapView: UIViewRepresentable {
    let coordinate: CLLocationCoordinate2D
    
    func makeUIView(context: Context) -> MKMapView {
        let mapView = MKMapView()
        mapView.showsUserLocation = true
        mapView.isZoomEnabled = false
        mapView.isScrollEnabled = false
        mapView.isRotateEnabled = false
        mapView.pointOfInterestFilter = .excludingAll
        return mapView
    }
    
    func updateUIView(_ uiView: MKMapView, context: Context) {
        let region = MKCoordinateRegion(
            center: coordinate,
            span: MKCoordinateSpan(latitudeDelta: 0.07, longitudeDelta: 0.07)
        )
        uiView.setRegion(region, animated: true)
        
        if let overlay = uiView.overlays.first {
            uiView.removeOverlay(overlay)
        }
    }
}

private func formatForecastTime(_ date: Date) -> String {
    let formatter = DateFormatter()
    formatter.dateFormat = "HH:mm\nMM/dd"
    return formatter.string(from: date)
}

struct WeatherDetailCard: View {
    let icon: String
    let title: String
    let value: String
    
    var body: some View {
        VStack(spacing: 5) {
            Image(systemName: icon)
                .font(.title)
                .fontWeight(.semibold)
                .foregroundColor(.white)
                
            Text(title)
                .font(.title3)
                .fontWeight(.bold)
                .foregroundColor(.white)
            
            Text(value)
                .font(.title3)
                .fontWeight(.bold)
                .foregroundColor(.white)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 20)
    }
}

struct HourlyForecastCard: View {
    let hour: String
    let temperature: Int
    let icon: String
    
    var body: some View {
        VStack(spacing: 10) {
            Text(hour)
                .font(.callout)
                .foregroundColor(.white)
                .multilineTextAlignment(.center)
            
            AsyncImage(url: URL(string: "https://openweathermap.org/img/wn/\(icon)@2x.png")) { image in
                image
                    .resizable()
                    .scaledToFit()
                    .frame(width: 40, height: 40)
            } placeholder: {
                Image(systemName: "cloud.sun.fill")
                    .font(.title2)
                    .foregroundColor(.white)
            }
            
            Text("\(temperature)°")
                .font(.title3)
                .fontWeight(.semibold)
                .foregroundColor(.white)
        }
        .padding(.vertical, 15)
        .padding(.horizontal, 12)
        .background(
            RoundedRectangle(cornerRadius: 20)
                .fill(.ultraThinMaterial)
        )
    }
}

struct CityWeatherDetailView_Previews: PreviewProvider {
    static var previews: some View {
        CityWeatherDetailView(
            city: City(
                name: "New York",
                temperature: 12.0,
                weatherDescription: "Clear sky",
                weatherIcon: "01d",
                localTime: Date(),
                country: "US",
                timeZone: "America/New_York",
                coordinates: Coordinates(lat: 40.7128, lon: -74.0060),
                humidity: 65,
                windSpeed: 5.2
                
            ),
            viewModel: WeatherViewModel()
        )
    }
}

================
File: MAD9137_Final Assignment_Weather Application/Views/ContentView.swift
================
//
//  ContentView.swift
//  MAD9137_Final Assignment_Weather Application
//
//  Created by Terry Wong on 11/12/2024.
//

import SwiftUI

struct ContentView: View {
    @EnvironmentObject var weatherViewModel: WeatherViewModel

    var body: some View {
        MainTabView()
            .environmentObject(weatherViewModel)
    }
}

================
File: MAD9137_Final Assignment_Weather Application/Views/MainTabView.swift
================
//
//  MainTabView.swift
//  MAD9137_Final Assignment_Weather Application
//
//  Created by Terry Wong on 12/12/2024.
//

import SwiftUI

struct MainTabView: View {
    @StateObject private var weatherViewModel = WeatherViewModel()

    init() {
        // Make tab bar transparent
        UITabBar.appearance().backgroundColor = .black.withAlphaComponent(0.8)
        UITabBar.appearance().barTintColor = .clear
    }

    var body: some View {
        TabView {
            CityListView()
                .environmentObject(weatherViewModel)
                .tabItem {
                    Image(systemName: "building.2")
                    Text("Cities")
                }

            SettingsView()
                .environmentObject(weatherViewModel)
                .tabItem {
                    Image(systemName: "gear")
                    Text("Settings")
                }
        }
    }
}

struct MainTabView_Previews: PreviewProvider {
    static var previews: some View {
        MainTabView()
    }
}

================
File: MAD9137_Final Assignment_Weather Application/Views/SearchCityView.swift
================
//
//  SearchCityView.swift
//  MAD9137_Final Assignment_Weather Application
//
//  Created by Terry Wong on 11/12/2024.
//

import SwiftUI

struct SearchCityView: View {
    @Environment(\.dismiss) var dismiss
    @State private var searchText = ""
    @EnvironmentObject var weatherViewModel: WeatherViewModel
    @State private var showAlert = false
    @State private var alertMessage = ""
    @State private var isLoading = false
    @State private var searchResults: [City] = []
    @State private var selectedCity: String? = nil // Track which city is being loaded

    let weatherService = WeatherService()
    let popularCities = ["Tokyo", "New York", "Dubai", "London"]
    let allCities = ["Hong Kong", "Beijing", "Delhi", "Chennai", "Istanbul",
                     "Singapore", "Rome", "Mumbai", "Jakarta", "Tokyo", "Seoul"]

    func fetchAndAddCity(_ cityName: String) {
        isLoading = true
        selectedCity = cityName
        Task {
            do {
                let weatherData = try await weatherService.fetchWeather(for: cityName)
                let city = City(
                    name: weatherData.name,
                    temperature: weatherData.main.temp,
                    weatherDescription: weatherData.weather.first?.description ?? "",
                    weatherIcon: weatherData.weather.first?.icon ?? "",
                    localTime: Date(),
                    country: weatherData.sys.country,
                    timeZone: nil,
                    coordinates: Coordinates(lat: weatherData.coord.lat, lon: weatherData.coord.lon),
                    humidity: weatherData.main.humidity,
                    windSpeed: weatherData.wind.speed
                )
                await MainActor.run {
                    weatherViewModel.addCity(city)
                    isLoading = false
                    selectedCity = nil
                    dismiss()
                }
            } catch {
                await MainActor.run {
                    isLoading = false
                    selectedCity = nil
                    alertMessage = "Could not find weather for this city. Please try again."
                    showAlert = true
                }
            }
        }
    }

    func performSearch(query: String) {
        Task {
            do {
                let weatherData = try await weatherService.fetchWeather(for: query)
                let city = City(
                    name: weatherData.name,
                    temperature: weatherData.main.temp,
                    weatherDescription: weatherData.weather.first?.description ?? "",
                    weatherIcon: weatherData.weather.first?.icon ?? "",
                    localTime: Date(),
                    country: weatherData.sys.country,
                    timeZone: nil,
                    coordinates: Coordinates(lat: weatherData.coord.lat, lon: weatherData.coord.lon),
                    humidity: weatherData.main.humidity,
                    windSpeed: weatherData.wind.speed
                )
                await MainActor.run {
                    searchResults = [city]
                }
            } catch {
                await MainActor.run {
                    searchResults = []
                }
            }
        }
    }

    var body: some View {
        NavigationView {
            ZStack {
                Color.white
                    .ignoresSafeArea()

                VStack(spacing: 20) {
                    if !searchText.isEmpty {
                        List(searchResults) { city in
                            HStack {
                                Text(city.name)
                                Spacer()
                                Text(city.country)
                            }
                            .onTapGesture {
                                weatherViewModel.addCity(city)
                                dismiss()
                            }
                        }
                    } else {
                        VStack(alignment: .leading) {
                            Text("Popular Cities")
                                .foregroundColor(.black)
                                .padding(.leading)

                            ScrollView(.horizontal, showsIndicators: false) {
                                HStack {
                                    ForEach(popularCities, id: \.self) { city in
                                        HStack {
                                            Text(city)
                                            if selectedCity == city && isLoading {
                                                ProgressView()
                                                    .scaleEffect(0.8)
                                            }
                                        }
                                        .padding(.horizontal, 20)
                                        .padding(.vertical, 8)
                                        .background(Color.gray.opacity(0.2))
                                        .cornerRadius(20)
                                        .foregroundColor(.black)
                                        .onTapGesture {
                                            fetchAndAddCity(city)
                                        }
                                    }
                                }
                                .padding(.horizontal)
                            }
                        }

                        ScrollView {
                            VStack(spacing: 0) {
                                ForEach(allCities, id: \.self) { city in
                                    HStack {
                                        Text(city)
                                            .foregroundColor(.black)
                                        Spacer()
                                        if selectedCity == city && isLoading {
                                            ProgressView()
                                                .scaleEffect(0.8)
                                        } else {
                                            Image(systemName: "plus")
                                                .foregroundColor(.black)
                                        }
                                    }
                                    .padding()
                                    .contentShape(Rectangle())
                                    .onTapGesture {
                                        fetchAndAddCity(city)
                                    }
                                    Divider()
                                        .background(Color.gray.opacity(0.3))
                                }
                            }
                        }
                    }
                }
            }
            .searchable(text: $searchText, prompt: "Search for a city...")
            .onChange(of: searchText) { newValue in
                if newValue.count >= 3 {
                    performSearch(query: newValue)
                } else {
                    searchResults = []
                }
            }
            .onSubmit(of: .search) {
                if !searchText.isEmpty {
                    fetchAndAddCity(searchText)
                }
            }
            .alert("Error", isPresented: $showAlert) {
                Button("OK", role: .cancel) {}
            } message: {
                Text(alertMessage)
            }
            .navigationBarTitleDisplayMode(.inline)
            .navigationTitle("Search for City")
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(action: {
                        dismiss()
                    }) {
                        Image(systemName: "chevron.left")
                            .foregroundColor(.black)
                    }
                }
            }
        }
    }
}

#Preview {
    SearchCityView()
        .environmentObject(WeatherViewModel())
}

================
File: MAD9137_Final Assignment_Weather Application/Views/SettingsView.swift
================
//
//  SettingsView.swift
//  MAD9137_Final Assignment_Weather Application
//
//  Created by Terry Wong on 12/12/2024.
//

import SwiftUI

struct SettingsView: View {
    @EnvironmentObject var viewModel: WeatherViewModel
    @AppStorage("refreshInterval") private var refreshInterval: TimeInterval = 60.0 {
        didSet {
            viewModel.updateRefreshTimer(interval: refreshInterval)
        }
    }

    let refreshIntervalOptions: [(String, TimeInterval)] = [
        ("1 minute", 60),
        ("5 minutes", 300),
        ("15 minutes", 900),
        ("30 minutes", 1800),
        ("1 hour", 3600)
    ]

    var body: some View {
        NavigationStack {
            ZStack {
                Color(red: 0.4, green: 0.5, blue: 0.9)
                    .ignoresSafeArea()
                List {
                    Picker("Refresh Interval", selection: $refreshInterval) {
                        ForEach(refreshIntervalOptions, id: \.1) { option in
                            Text(option.0).tag(option.1)
                        }
                    }

                    Section {
                        NavigationLink {
                            AboutView()
                        } label: {
                            Text("About")
                        }
                    }
                }
                .scrollContentBackground(.hidden)
            }
            .navigationTitle("Settings")
            .navigationBarTitleDisplayMode(.inline)
            .toolbarBackground(Color(red: 0.4, green: 0.5, blue: 0.9), for: .navigationBar)
            .toolbarBackground(.visible)
            .toolbarColorScheme(.dark, for: .navigationBar)
        }
        .onAppear {
            // Ensure timer is running with current interval when view appears
            viewModel.updateRefreshTimer(interval: refreshInterval)
        }
    }
}

struct SettingsView_Previews: PreviewProvider {
    static var previews: some View {
        SettingsView()
            .environmentObject(WeatherViewModel())
    }
}

================
File: MAD9137_Final Assignment_Weather Application/MAD9137_Final_Assignment_Weather_ApplicationApp.swift
================
//
//  MAD9137_Final_Assignment_Weather_ApplicationApp.swift
//  MAD9137_Final Assignment_Weather Application
//
//  Created by Terry Wong on 10/12/2024.
//

import SwiftUI

@main
struct WeatherApp: App {
    @StateObject private var weatherViewModel = WeatherViewModel()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(weatherViewModel)
        }
    }
}

================
File: MAD9137_Final Assignment_Weather Application.xcodeproj/project.xcworkspace/contents.xcworkspacedata
================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>

================
File: MAD9137_Final Assignment_Weather Application.xcodeproj/xcuserdata/terrywong.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
================
<?xml version="1.0" encoding="UTF-8"?>
<Bucket
   uuid = "3B31DA25-F7A4-45D0-9518-0DCEE0AFEFC1"
   type = "1"
   version = "2.0">
</Bucket>

================
File: MAD9137_Final Assignment_Weather Application.xcodeproj/xcuserdata/terrywong.xcuserdatad/xcschemes/xcschememanagement.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>MAD9137_Final Assignment_Weather Application.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
	</dict>
</dict>
</plist>

================
File: MAD9137_Final Assignment_Weather Application.xcodeproj/project.pbxproj
================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 77;
	objects = {

/* Begin PBXFileReference section */
		1FB104142D08C1C5001A3C85 /* MAD9137_Final Assignment_Weather Application.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = "MAD9137_Final Assignment_Weather Application.app"; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFileSystemSynchronizedRootGroup section */
		1FB103AE2D08B2E6001A3C85 /* MAD9137_Final Assignment_Weather Application */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = "MAD9137_Final Assignment_Weather Application";
			sourceTree = "<group>";
		};
/* End PBXFileSystemSynchronizedRootGroup section */

/* Begin PBXFrameworksBuildPhase section */
		1FB103A92D08B2E6001A3C85 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		1FB103A32D08B2E6001A3C85 = {
			isa = PBXGroup;
			children = (
				1FB103AE2D08B2E6001A3C85 /* MAD9137_Final Assignment_Weather Application */,
				1FB104142D08C1C5001A3C85 /* MAD9137_Final Assignment_Weather Application.app */,
			);
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		1FB103AB2D08B2E6001A3C85 /* MAD9137_Final Assignment_Weather Application */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 1FB103BA2D08B2E8001A3C85 /* Build configuration list for PBXNativeTarget "MAD9137_Final Assignment_Weather Application" */;
			buildPhases = (
				1FB103A82D08B2E6001A3C85 /* Sources */,
				1FB103A92D08B2E6001A3C85 /* Frameworks */,
				1FB103AA2D08B2E6001A3C85 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				1FB103AE2D08B2E6001A3C85 /* MAD9137_Final Assignment_Weather Application */,
			);
			name = "MAD9137_Final Assignment_Weather Application";
			packageProductDependencies = (
			);
			productName = "MAD9137_Final Assignment_Weather Application";
			productReference = 1FB104142D08C1C5001A3C85 /* MAD9137_Final Assignment_Weather Application.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		1FB103A42D08B2E6001A3C85 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1610;
				LastUpgradeCheck = 1610;
				TargetAttributes = {
					1FB103AB2D08B2E6001A3C85 = {
						CreatedOnToolsVersion = 16.1;
					};
				};
			};
			buildConfigurationList = 1FB103A72D08B2E6001A3C85 /* Build configuration list for PBXProject "MAD9137_Final Assignment_Weather Application" */;
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 1FB103A32D08B2E6001A3C85;
			minimizedProjectReferenceProxies = 1;
			preferredProjectObjectVersion = 77;
			productRefGroup = 1FB103A32D08B2E6001A3C85;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				1FB103AB2D08B2E6001A3C85 /* MAD9137_Final Assignment_Weather Application */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		1FB103AA2D08B2E6001A3C85 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		1FB103A82D08B2E6001A3C85 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		1FB103B82D08B2E8001A3C85 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.1;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		1FB103B92D08B2E8001A3C85 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.1;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		1FB103BB2D08B2E8001A3C85 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"MAD9137_Final Assignment_Weather Application/Preview Content\"";
				DEVELOPMENT_TEAM = 39JGDR8LL6;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "MAD9137-Final-Assignment-Weather-Application-Info.plist";
				INFOPLIST_KEY_CFBundleDisplayName = "";
				INFOPLIST_KEY_LSApplicationCategoryType = "";
				INFOPLIST_KEY_NSLocationAlwaysAndWhenInUseUsageDescription = "We need your location to show weather information on the map.";
				INFOPLIST_KEY_NSLocationAlwaysUsageDescription = "We need your location to show weather information on the map.";
				INFOPLIST_KEY_NSLocationWhenInUseUsageDescription = "We need your location to show weather information on the map.";
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "com.algonquincollege.MAD9137-Final-Assignment-Weather-Application";
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		1FB103BC2D08B2E8001A3C85 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"MAD9137_Final Assignment_Weather Application/Preview Content\"";
				DEVELOPMENT_TEAM = 39JGDR8LL6;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "MAD9137-Final-Assignment-Weather-Application-Info.plist";
				INFOPLIST_KEY_CFBundleDisplayName = "";
				INFOPLIST_KEY_LSApplicationCategoryType = "";
				INFOPLIST_KEY_NSLocationAlwaysAndWhenInUseUsageDescription = "We need your location to show weather information on the map.";
				INFOPLIST_KEY_NSLocationAlwaysUsageDescription = "We need your location to show weather information on the map.";
				INFOPLIST_KEY_NSLocationWhenInUseUsageDescription = "We need your location to show weather information on the map.";
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "com.algonquincollege.MAD9137-Final-Assignment-Weather-Application";
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		1FB103A72D08B2E6001A3C85 /* Build configuration list for PBXProject "MAD9137_Final Assignment_Weather Application" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				1FB103B82D08B2E8001A3C85 /* Debug */,
				1FB103B92D08B2E8001A3C85 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		1FB103BA2D08B2E8001A3C85 /* Build configuration list for PBXNativeTarget "MAD9137_Final Assignment_Weather Application" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				1FB103BB2D08B2E8001A3C85 /* Debug */,
				1FB103BC2D08B2E8001A3C85 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 1FB103A42D08B2E6001A3C85 /* Project object */;
}

================
File: File.txt
================
CityWeatherRow.swift

================
File: MAD9137-Final-Assignment-Weather-Application-Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Allow Arbitrary Loads</key>
	<string>YES</string>
	<key>NSAppTransportSecurity</key>
	<dict>
		<key>AllowsArbitraryLoadsInWebContent</key>
		<true/>
		<key>NSAllowsArbitraryLoads</key>
		<true/>
	</dict>
</dict>
</plist>
